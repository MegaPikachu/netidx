* 0.6.0:
  - Plug a couple of holes that could allow non canonical paths to be
    created
  - Fix a bunch of bugs coming from an incorrect test for path
    parenthood.
  - New tool, netidx recorder, records subscriptions to compact
    archive files, and also publishes archive files.
  - Implement From on Value for most primitive types.
  - Add a trait, FromValue, that behaves like FromStr, and implement
    it for many primitive types
  - Add list_matching, get_changeid methods to ResolverRead. Both
    methods can't be used with older resolver servers, however older
    clients can still talk to a newer resolver server.
  - Tune the resolver server to give much higher priority to Resolve
    over List and Table calls to compensate for the potentially large
    traffic caused by list_recursive and list_glob. A List/Table call
    now "costs" 10K Resolve calls, so the max batch size of a read
    client doing only List calls is now 100 instead of 1000K.
  - Fix a bug in the resolver that could cause a referral loop with
    deeply nested resolver clusters.

* 0.5.1:
  - Resolver server: improve the performance of sharding (eliminate
    integer division) for a noticable speedup processing large
    batches.
  - Put an upper bound on total pool size to avoid various extreme
    scenarios causing unbounded memory usage.
  - Pool more buffers in the resolver server to reduce dynamic
    allocation.
  - Fix a bug in the new sharded resolver store that broke default
    publishing.
  - Fix unit tests.

* 0.5.0:
  - Update to tokio 0.3 aka 1.0
  - Implement timeout logic in the resolver client to deal with the
    case where a resolver server is hung. The rule is, minimum timeout
    15 seconds or 6 microseconds per operation in the batch for reads
    and 12 microseconds per operation in the batch for writes,
    whichever timeout is longer.
  - Limit reads and writes to a maximum batch size to prevent doing
    too much work at once on a tokio worker thread, and reader/writer
    starvation, The max batch sizes are are 1000K ops for readers and
    100K ops for writers. Cleaning up dead publishers are included in
    these limits. Results are flushed back to the client after each
    chunk so that we interact properly with the hang detection feature
    mentioned above.
  - The resolver now uses all cores for reads and writes, and no longer
    uses locking, instead the database is sharded internally with each
    CPU controlling a shard. Batches are hashed by path and sent out
    to their corresponding shard (or all of them in the case of
    e.g. list). Performance for large publishers and/or lots of
    publishers on machines with a lot of cores is vastly improved.
  - Improve a degenerate case in resolver_store when lots of
    publishers publish the same paths. It's still N^2, but the
    constants are much better, and it's now not an issue to get to
    thousands of publishers publishing the same set of paths, probably
    more than you'd ever want in practice.
  - Fix a bug in the resolver client that would cause a long running
    write connection to stop after the heartbeat interval.
  - Fix a design flaw in the secstore. Now it will always keep the
    security context around for a publisher for as long as that
    publisher is alive.
  - Caching of read security contexts is no longer supported after I
    found that some (older) implementations of kerberos hold an open
    file per ctx for the replay cache. Since we must keep a live ctx
    for each live publisher you may need to raise the allowed number
    of open file descriptors to avoid starvation if you use an
    effected kerberos distribution. The number of open files should be
    at least P + 2*C, where P is the number of publishers and C is the
    number of allowed simultaneous connections. Alternatively you can
    disable the replay cache by setting KRB5RCACHETYPE=none. This is
    not recommended as it opens you to token replay attacks.
  - Fix a bug in the resolver server connection tracking logic that
    caused the number of counted open connections to be higher than
    the actual number when the counted connections are live publishers
    that are heartbeating but not actually connected. This could cause
    read and write starvation with a large number of publishers.
  - No longer fail publisher flushes when the publisher can't reach
    any resolver server, instead log the error and keep trying
    forever. There is just no combination of timeouts and or logic
    that seems better. The means that publisher::flush now cannot fail.
  - Fix a bug in publisher that would cause new published names not to
    be sent to the resolver if they are queued while a flush operation
    is in progress.
  - NO protocol changes in 0.5, it's safe to mix any 0.5 with any 0.4
    component. The major version bump is due to tokio 0.3 being a
    potentially large change.

* 0.4.2:
  - Fix browser design mode widget highlights are wrong when there are
    nested grids.
  - Maybe fix an intermittant issue with design mode where invisible
    widgets are still interactable in the properties view and the
    visible widgets are not.
  - Make the WIP book the homepage

* 0.4.1:
  - Fix browser can't get out of raw mode.
  - Subscriber: Tweak the semantics when registering a duplicate
    channel for updates on a subscription. Now, if begin_with_last is
    true, the duplicate channel will receive an update with the current
    state even though the registration will be ignored.
  - Reduce allocation in the command line publisher.
  - Fix a bug in the resolver store that would result in ghost columns
    remaining in the browser even after data was removed. Enhanced
    tests to cover the columns method.
  - Fix a bug in resolver store that would result in a list of a path
    with a trailing slash recursively listing all children. While this
    might seem useful it wouldn't work in a hierarchical cluster, so
    the easiest thing to do is remove it. In any case for a large
    server it could be quite a bit more dangerous than a simple list,
    especially if triggered accidentally.
  - Change the way null is published in the shell publisher such that
    it is possible to publish a string "null", sorry :facepalm:.
  - Fix subscriber connection might decide it's idle and disconnect
    when there are pending subscription requests in it's
    queue. subscriber will now disconnect immediatly when the last
    subscription is unsubscribed and there are no queued
    subscriptions.

* 0.4.0:
  - protocol breaking changes (additions). 0.4 will be the last non
    backwards compatible protocol, from here on protocol breaking
    changes will introduce a new protocol version, and new library
    versions will be able to speak to old clients using at least one
    protocol version less than the current one.
  - allow publisher to unicast to specific subscribers
  - writes can return success or failure instead of silently eating
    errors. This behavior is not mandatory, as it has a performance
    impact.
  - netidx browser is now a separate binary from the tools
  - netidx browser "views", publishable and editable custom guis
  - subscriber will notify explicitly when a subscription is
    unsubscribed. This imposes minimal to no overhead due to rust
    being awesome
  - simplify durable subscriber, shrink it's memory usage a couple of
    words per subscription
  - eliminate a race between durable subscriber subscription state and
    updates. Facepalm averted.
  - add many useful value types, e.g. Result, DateTime, Duration
  - It is now possible to build on Mac OS by disabling the (default)
    krb5_iov feature. This will result in reduced performance when
    talking to encrypted services, but it works.
  - netidx-protocols breaking. View definitions are not backwards
    compatible with 0.3, and given how much development is going on in
    the browser I would expect more breaking changes to view
    definitions for a while. At some point it will settle down, and I
    will start to version that protocol just like the
    resolver/publisher protocol, but for the moment it's much easier
    to just move fast and break it.
  - various improvements to the command line tools, some of which are
    breaking changes. e.g. publisher and subscriber write now take a
    triple of path, type, value, instead of path, value.

* 0.3.2:
  - minor api enhancement. add update_changed, and current to
    publisher::Val

* 0.3.1:
  - make publisher::Id public again, sorry!

* 0.3.0:
  - basic netidx browser added to tools, more is planned for it
  - protocol not compatible with previous versions
  - subscriber Val::last and Dval::last are no longer async

* 0.2.0:
  - trim tokio features to the required set
  - config in dns is removed due to limitations, which is really sad
    because it was damn cool
  - reduce buffer slack
  - fix a few cases where we didn't set tcp nodelay
  - many windows releated bugs fixed
  - test extensively on windows
  - protocol not compatible with previous versions

* 0.1.2:
  - Experimental support for publisher/subscriber on windows

* 0.1.1:
  - Fix some bugs

* 0.1.0:
  -Initial release
