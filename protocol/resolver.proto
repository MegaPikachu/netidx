syntax = "proto3";
import "shared.proto";

// This is the first message sent by the client after it initiates a
// transport session with the server. It is always sent in the
// clear. Clients must decide at hello time whether they will be read
// only, or write only, this determines what protocol the server
// speaks to them. There is no read/write form.
message ClientHello {
  // this variant marks the client as read only. The server will
  // respond with a ServerHelloRead message, and speak the read
  // protocol thereafter.
  message Read {
    // the client wishes to remain anonymous.
    message Anonymous {}

    // the client wishes to reuse an existing gssapi session named by
    // the session_id parameter.
    message Reuse {
      uint64 session_id = 1;
    }

    // the client wishes to initiate a new gssapi session with the
    // specified token.
    message Initiate {
      bytes token = 1;
    }

    oneof auth {
      Anonymous Anonymous = 1;
      Reuse Reuse = 2;
      Initiate Initiate = 3;
    }
  }

  // this variant marks the client as write only. The server will
  // respond with a ServerHelloWrite message, and thereafter speak the
  // write protocol.
  message Write {
    message Auth {
      // the publisher wants to remain anonymous
      message Anonymous {}

      // the publisher wants to reuse an existing gssapi session
      message Reuse {}

      // the publisher wants to initiate a new gssapi session
      message Initiate {
        string spn = 1; // the publisher's service principal name
        bytes token = 2; // gssapi auth token
      }

      oneof auth {
        Anonymous Anonymous = 1;
        Reuse Reuse = 2; // the socketaddr identifies the session
        Initiate Initiate = 3;
      }
    }

    // the publishers listener address, all published values will
    // point to this address
    SocketAddr write_addr = 1;
    Auth auth = 2;
  }

  oneof hello {
    Read ReadOnly = 1;
    Write WriteOnly = 2;
  }
}

// first server message sent to read only clients
message ServerHelloRead {
  // the server will remain anonymous
  message Anonymous {}

  // the server has accepted the client's request to reuse a gssapi session
  message Reused {}

  // the server has accepted the client's request to initiate a new gssapi session
  message Accepted {
    uint64 context_id = 1; // the session may be reused by referencing this id
    bytes token = 2; // gssapi mutual auth token, authenticating the server to the client
  }

  oneof auth {
    Anonymous Anonymous = 1;
    Reused Reused = 2;
    Accepted Accepted = 3;
  }
}

// first server message sent to write only clients
message ServerHelloWrite {
  // the server will remain anonymous
  message Anonymous {}

  // the server has accepted the client's request to reuse a gssapi session
  message Reused {}

  // the server has accepted the client's request to initiate a new gssapi session
  message Accepted {
    bytes token = 1; // gssapi mutual auth token, authenticating the server to the client
  }

  // previous entries that may have been published by this publisher
  // have expired and have been purged. If such entries exist the
  // publisher should publish them again.
  bool ttl_expired = 1;
  uint64 resolver_id = 2; // the unique id of this resolver server
  oneof auth {
    Anonymous Anonymous = 3;
    Reused Reused = 4;
    Accepted Accepted = 5;
  }
}

// sent to the server by read only clients
message ReadClientRequest {
  // request to resolve the specified paths into publisher addresses
  message Resolve {
    repeated string path = 1;
  }

  // request to list immediate children of the specified path
  message List {
    string path = 1;
  }

  oneof request {
    Resolve Resolve = 1;
    List List = 2;
  }
}

// sent by the server to read only clients
message ReadServerResponse {
  // mapping of the publisher address to the krb5 service principal
  // name needed for gssapi session initiation to the publisher.
  message Krb5SpnMapping {
    SocketAddr addr = 1;
    string spn = 2;
  }

  message AddrAndAuthToken {
    SocketAddr addr = 1; // publisher address
    bytes token = 2; // encrypted permission token, when decrypted type is PermissionToken
  }

  // each path can have multiple publishers publishing it
  message Resolution {
    repeated AddrAndAuthToken addrs = 1;
  }

  // this is the response to a successful Resolve request
  message Resolved {
    uint64 resolver_id = 1; // the id of this resolver
    repeated Krb5SpnMapping krb5_spns = 2;
    repeated Resolution results = 3;
  }

  // this is the response to a successful List request
  message List {
    repeated string path = 1;
  }

  // this the response to any request that is not successful
  message Error {
    string description = 1;
  }

  oneof response {
    Resolved Resolved = 1;
    List List = 2;
    Error Error = 3;
  }
}

// sent by write only clients to the resolver server
message WriteClientRequest {
  // request to publish one or more paths
  message Publish {
    repeated string path = 1;
  }

  // request to stop publishing one or more paths
  message Unpublish {
    repeated string path = 1;
  }

  // clear all paths published by this client
  message Clear {}

  message Heartbeat {}

  oneof request {
    Publish Publish = 1;
    Unpublish Unpublish = 2;
    Clear Clear = 3;
    Heartbeat Heartbeat = 4;
  }
}

// sent by the server to write only clients
message WriteServerResponse {
  // indicates the request to publish was successful
  message Published {}

  // indicates the request to unpublish was successful
  message Unpublished {}

  // the previous request was not successful
  message Error {
    string description = 1;
  }

  oneof response {
    Published Published = 1;
    Unpublished Unpublished = 2;
    Error Error = 3;
  }
}
